<h1>About</h1>
<p>wcm2022</p>
<p>41023120</p>
<p>倉儲:<a href="https://github.com/41023120/wcm2022">https://github.com/41023120/wcm2022</a></p>
<p>作業網頁  https://41023120.github.io/wcm2022/content/index.html</p>
<h2>run</h2>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js">
</script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 印出版次與關鍵字程式 --></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd(ev):
    bd = doc["brython_div"]
    bd.clear()
# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/cango_gear1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace.editor.setValue(prog)
    Ace.editor.scrollToRow(0)
    Ace.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
doc['clear_bd'].bind('click', clear_bd)
# 呼叫函式執行
run()
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<!-- 存擋表單開始 --><form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src', 'kw_filename');" type="submit" value="Save"/></form><!-- 存擋表單結束 -->
<p></p>
<!-- 執行與清除按鈕開始 -->
<p><button id="kw_run">Run</button> <button id="kw_show_console">Output</button> <button id="kw_clear_console">清除輸出區</button><button id="clear_bd">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<!-- 執行與清除按鈕結束 -->
<p></p>
<!-- 程式執行 ouput 區 -->
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console"></textarea></div>
<!-- Brython 程式執行的結果, 都以 brython_div 作為切入位置 -->
<div id="brython_div"></div>
<div></div>
<div>
<h1>w13</h1>
<p>R為旋轉方塊</p>
<p><span>左右</span>方向鍵可以控制方塊移動</p>
<p><span>D為直接將方塊快速往下移動</span></p>
<p> </p>
<!-- 導入 brython 程式庫 -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
<div id="brython_div"></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<script type="text/python">
# from https://levelup.gitconnected.com/writing-tetris-in-python-2a16bddb5318
# 暫時關閉 system proxy 設定後,  pip install pygame
#import pygame
import random
# 以下為 Brython 新增
from browser import document as doc
from browser import html
import browser.timer

# 利用 html 建立一個 CANVAS 標註物件, 與變數 canvas 對應
canvas = html.CANVAS(width = 400, height = 500, id="canvas")
brython_div = doc["brython_div"]
brython_div <= canvas
ctx = canvas.getContext("2d")

colors = [
    (0, 0, 0),
    (120, 37, 179),
    (100, 179, 179),
    (80, 34, 22),
    (80, 134, 22),
    (180, 34, 22),
    (180, 34, 122),
]


class Figure:
    x = 0
    y = 0

    figures = [
        [[1, 5, 9, 13], [4, 5, 6, 7]],
        [[4, 5, 9, 10], [2, 6, 5, 9]],
        [[6, 7, 9, 10], [1, 5, 6, 10]],
        [[1, 2, 5, 9], [0, 4, 5, 6], [1, 5, 9, 8], [4, 5, 6, 10]],
        [[1, 2, 6, 10], [5, 6, 7, 9], [2, 6, 10, 11], [3, 5, 6, 7]],
        [[1, 4, 5, 6], [1, 4, 5, 9], [4, 5, 6, 9], [1, 5, 6, 9]],
        [[1, 2, 5, 6]],
    ]

    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.type = random.randint(0, len(self.figures) - 1)
        self.color = random.randint(1, len(colors) - 1)
        self.rotation = 0

    def image(self):
        return self.figures[self.type][self.rotation]

    def rotate(self):
        self.rotation = (self.rotation + 1) % len(self.figures[self.type])


class Tetris:
    level = 2
    score = 0
    state = "start"
    field = []
    height = 0
    width = 0
    x = 100
    y = 60
    zoom = 20
    figure = None

    def __init__(self, height, width):
        self.height = height
        self.width = width
        self.field = []
        self.score = 0
        self.state = "start"
        for i in range(height):
            new_line = []
            for j in range(width):
                # 起始時每一個都填入 0
                new_line.append(0)
            self.field.append(new_line)

    def new_figure(self):
        self.figure = Figure(3, 0)

    def intersects(self):
        intersection = False
        for i in range(4):
            for j in range(4):
                if i * 4 + j in self.figure.image():
                    # block 到達底部, 左右兩邊界, 或該座標有其他 block
                    if i + self.figure.y > self.height - 1 or \
                            j + self.figure.x > self.width - 1 or \
                            j + self.figure.x < 0 or \
                            self.field[i + self.figure.y][j + self.figure.x] > 0:
                        intersection = True
        return intersection

    def break_lines(self):
        lines = 0
        for i in range(1, self.height):
            zeros = 0
            for j in range(self.width):
                if self.field[i][j] == 0:
                    zeros += 1
            if zeros == 0:
                lines += 1
                for i1 in range(i, 1, -1):
                    for j in range(self.width):
                        self.field[i1][j] = self.field[i1 - 1][j]
        self.score += lines ** 2

    def go_space(self):
        while not self.intersects():
            self.figure.y += 1
        self.figure.y -= 1
        self.freeze()

    def go_down(self):
        self.figure.y += 1
        if self.intersects():
            self.figure.y -= 1
            self.freeze()

    def freeze(self):
        for i in range(4):
            for j in range(4):
                if i * 4 + j in self.figure.image():
                    self.field[i + self.figure.y][j + self.figure.x] = self.figure.color
        self.break_lines()
        self.new_figure()
        if self.intersects():
            self.state = "gameover"

    def go_side(self, dx):
        old_x = self.figure.x
        self.figure.x += dx
        if self.intersects():
            self.figure.x = old_x

    def rotate(self):
        old_rotation = self.figure.rotation
        self.figure.rotate()
        if self.intersects():
            self.figure.rotation = old_rotation

# Define some colors
# from https://stackoverflow.com/questions/3380726/converting-a-rgb-color-tuple-to-a-six-digit-code
BLACK = '#%02x%02x%02x' % (0, 0, 0)
WHITE = '#%02x%02x%02x' % (255, 255, 255)
GRAY = '#%02x%02x%02x' % (128, 128, 128)

done = False
fps = 25
game = Tetris(20, 10)
counter = 0

pressing_down = False

def key_down(eve):
    key = eve.keyCode
    #if event.type == pygame.QUIT:
    # 32 is pause
    if key == 32:
        done = True
    # 82 is r key to rotate
    if key == 82:
        game.rotate()
    # 40 is down key
    if key == 40:
        pressing_down = True
    # 37 is left key
    if key == 37:
        game.go_side(-1)
    # 39 is right key
    if key == 39:
        game.go_side(1)
    # 68 is d key to move block to bottom
    if key == 68:
        game.go_space()
    # 27 is escape
    # reset the game
    if key == 27:
        game.__init__(20, 10)

def key_up(eve):
    key = eve.keyCode
    # 40 is down key
    if key == 40:
        pressing_down = False

#while not done:
def do_game():
    global counter
    if game.figure is None:
        game.new_figure()
    counter += 1
    if counter > 100000:
        counter = 0
    if counter % (fps // game.level // 2) == 0 or pressing_down:
        if game.state == "start":
            game.go_down()
    
    for i in range(game.height):
        for j in range(game.width):
            ctx.fillStyle = WHITE
            #ctx.scale(game.zoom, game.zoom)
            ctx.fillRect(game.x + game.zoom * j, game.y + game.zoom * i, game.zoom, game.zoom)
            if game.field[i][j] > 0:
                ctx.fillStyle = '#%02x%02x%02x' % colors[game.field[i][j]]
                ctx.fillRect(game.x + game.zoom * j + 1, game.y + game.zoom * i + 1, game.zoom - 2, game.zoom - 1)
            ctx.lineWidth = 1
            ctx.strokeStyle = GRAY
            ctx.beginPath()
            ctx.rect(game.x + game.zoom * j, game.y + game.zoom * i, game.zoom, game.zoom)
            ctx.stroke()
    if game.figure is not None:
        for i in range(4):
            for j in range(4):
                p = i * 4 + j
                if p in game.figure.image():
                    ctx.fillStyle = '#%02x%02x%02x' % colors[game.figure.color]
                    ctx.fillRect(game.x + game.zoom * (j + game.figure.x) + 1,
                                      game.y + game.zoom * (i + game.figure.y) + 1,
                                      game.zoom - 2, game.zoom - 2)

doc.addEventListener("keydown", key_down)
doc.addEventListener("keyup", key_up)
browser.timer.set_interval(do_game, fps)
</script>
<h1>midterm</h1>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="630" src="/downloads/w8_project%20(1).mp4" title="YouTube video player" width="1008"></iframe></p>
<h1>w14</h1>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js">
</script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 印出版次與關鍵字程式 --></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd(ev):
    bd = doc["brython_div"]
    bd.clear()
# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/41023120-1/3ab6a78007865b9e03f05fe766a587fb/raw/c5e3dcfdc36615e6f867ab9c2888b488fc67a099/gistfile1.txt"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace.editor.setValue(prog)
    Ace.editor.scrollToRow(0)
    Ace.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
doc['clear_bd'].bind('click', clear_bd)
# 呼叫函式執行
run()
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<!-- 存擋表單開始 --><form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src', 'kw_filename');" type="submit" value="Save"/></form><!-- 存擋表單結束 -->
<p></p>
<!-- 執行與清除按鈕開始 -->
<p><button id="kw_run">Run</button> <button id="kw_show_console">Output</button> <button id="kw_clear_console">清除輸出區</button><button id="clear_bd">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<!-- 執行與清除按鈕結束 -->
<p></p>
<!-- 程式執行 ouput 區 -->
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console"></textarea></div>
<!-- Brython 程式執行的結果, 都以 brython_div 作為切入位置 -->
<div id="brython_div"></div>
<div></div>
<div></div>
<h2>1a分組名單</h2>
<p>1a github 帳號 組別<br/>30925140 30925140 1<br/>40623143 40623143 6<br/>40723141 s40723141 6<br/>40723207 s40723207 3<br/>40723226 s40723226 3<br/>40723229 s40723229 3<br/>40723233 s40723233 3<br/>40723239 s40723239 3<br/>40723245 s40723245 3<br/>40823132 40823132 6<br/>41023104 CHIA-ROU 5<br/>41023105 41023105 5<br/>41023108 KEHUEISIN 1<br/>41023110 41023110 1<br/>41023112 41023112 2<br/>41023118 41023118 4<br/>41023119 41023119 4<br/>41023120 41023120 4<br/>41023121 41023121 2<br/>41023122 lianian1120 4<br/>41023124 41023124 4<br/>41023125 41023125 4<br/>41023130 41023130 4<br/>41023131 george0324 4<br/>41023133 JIAN3-LIN 2<br/>41023134 41023134 2<br/>41023138 jamie_920130 1<br/>41023140 dan41023140 2<br/>41023142 41023142 1<br/>41023143 shih1717 2<br/>41023146 41023146 2<br/>41023147 Xiang0502 2<br/>41023148 6<br/>41023154 zeromarurei 1</p>
<p></p>
<p></p>
<p></p>
<h1>w17</h1>
<p></p>
<p>這一次玩的俄羅斯方塊我把fps改成了55讓他速度變慢讓我有更多時間去思考因為正常版fps是設定25我覺得太快,最後是得到73分。</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/iXfRHPrygyg" title="YouTube video player" width="560"></iframe></p>
<p></p>
<p></p>
<p>心得:這學期認識到很多新的知識關於網路跟虛擬主機和nginx,對俄羅斯方塊程式更深刻的了解,也知道了下次提交檔案時名稱要好好打,這樣別人看紀錄才會一目了然</p>
<p></p>
<p></p>
<p><br/><br/></p>
<h2>程式內容註解</h2>
<p>#41023120四設一甲呂昕叡</p>
<p>import random #匯入亂數模組<br/># 以下為 Brython 新增<br/>from browser import document as doc<br/>from browser import html<br/>import browser.timer<br/>#分數系統<br/>def update_score(new_score):<br/> score_doc.innerHTML = "Score: " + str(new_score)<br/># 利用 html 建立一個 CANVAS 標註物件, 與變數 canvas 對應<br/>canvas = html.CANVAS(width = 400, height = 500, id="canvas")<br/>brython_div = doc["brython_div"]<br/>brython_div &lt;= canvas<br/>ctx = canvas.getContext("2d")<br/>#方塊顏色表單<br/>colors = [<br/> (0, 0, 0),<br/> (120, 37, 179),<br/> (100, 179, 179),<br/> (80, 34, 22),<br/> (80, 134, 22),<br/> (180, 34, 22),<br/> (180, 34, 122),<br/>]</p>
<p>#建立方塊形狀<br/>class Figure:<br/> x = 0 #在格子裡的X軸<br/> y = 0 #在格子裡的y軸<br/>#方塊形狀表單<br/> figures = [<br/> [[1, 5, 9, 13], [4, 5, 6, 7]],<br/> [[4, 5, 9, 10], [2, 6, 5, 9]],<br/> [[6, 7, 9, 10], [1, 5, 6, 10]],<br/> [[1, 2, 5, 9], [0, 4, 5, 6], [1, 5, 9, 8], [4, 5, 6, 10]],<br/> [[1, 2, 6, 10], [5, 6, 7, 9], [2, 6, 10, 11], [3, 5, 6, 7]],<br/> [[1, 4, 5, 6], [1, 4, 5, 9], [4, 5, 6, 9], [1, 5, 6, 9]],<br/> [[1, 2, 5, 6]],<br/> ]<br/>#建立初始化函數 <br/> def __init__(self, x, y):<br/> self.x = x #建立變量<br/> self.y = y #建立變量<br/> self.type = random.randint(0, len(self.figures) - 1) #建立變量<br/> self.color = random.randint(1, len(colors) - 1) #在顏色表單裡隨意取一個數<br/> self.rotation = 0 #要旋轉一個方塊的時候默認值為零<br/>#建立基本功能<br/> def image(self):<br/> return self.figures[self.type][self.rotation]<br/>#旋轉功能<br/> def rotate(self):<br/> self.rotation = (self.rotation + 1) % len(self.figures[self.type])</p>
<p>#新建另一個類俄羅斯方塊<br/>class Tetris:<br/> level = 2<br/> score = 0 #分數<br/> state = "start" #狀態<br/> field = [] #格子數<br/> height = 0 #高度<br/> width = 0 #寬度<br/> x = 100 #介面外面寬<br/> y = 60 #介面外面長<br/> zoom = 20 #沒一個方塊的格子長寬<br/> figure = None #設方塊初始值<br/>#初始化函數<br/> def __init__(self, height, width):<br/> self.height = height #高度<br/> self.width = width #寬度<br/> self.field = [] #給格子初始化的表單值<br/> self.score = 0 #分數默認值為零<br/> self.state = "start" #賦予狀態<br/> for i in range(height): <br/> new_line = [] #新行<br/> for j in range(width): #每一列都行使相同的操作<br/> # 起始默認時每一個都填入 0<br/> new_line.append(0)<br/> self.field.append(new_line) #放進格子裡面<br/>#新建方塊<br/> def new_figure(self):<br/> self.figure = Figure(3, 0) #一開始就放在橫坐標的3.0的位置</p>
<p>def intersects(self):<br/> intersection = False<br/> for i in range(4):<br/> for j in range(4):<br/> if i * 4 + j in self.figure.image():<br/> # block 到達底部, 左右兩邊界, 或該座標有其他 block<br/> if i + self.figure.y &gt; self.height - 1 or \<br/> j + self.figure.x &gt; self.width - 1 or \<br/> j + self.figure.x &lt; 0 or \<br/> self.field[i + self.figure.y][j + self.figure.x] &gt; 0:<br/> intersection = True<br/> return intersection<br/>#把滿的那一行消除掉<br/> def break_lines(self):<br/> lines = 0<br/> for i in range(1, self.height):<br/> zeros = 0<br/> for j in range(self.width):<br/> if self.field[i][j] == 0:<br/> zeros += 1<br/> if zeros == 0:<br/> lines += 1<br/> for i1 in range(i, 1, -1):<br/> for j in range(self.width):<br/> self.field[i1][j] = self.field[i1 - 1][j]<br/> self.score += lines ** 2<br/> update_score(self.score)<br/>#瞬間往下掉直到碰到其他方塊<br/> def go_space(self):<br/> while not self.intersects():<br/> self.figure.y += 1<br/> self.figure.y -= 1<br/> self.freeze()<br/>#往下掉的功能<br/> def go_down(self):<br/> self.figure.y += 1<br/> if self.intersects(): #是否交互<br/> self.figure.y -= 1<br/> self.freeze()<br/>#檢查每一列有沒有方塊<br/> def freeze(self):<br/> for i in range(4): <br/> for j in range(4):<br/> if i * 4 + j in self.figure.image():<br/> self.field[i + self.figure.y][j + self.figure.x] = self.figure.color<br/> self.break_lines() <br/> self.new_figure()<br/> if self.intersects(): #如果還是交互了就gameover<br/> self.state = "gameover"<br/>#往邊線去走<br/> def go_side(self, dx):<br/> old_x = self.figure.x<br/> self.figure.x += dx<br/> if self.intersects():<br/> self.figure.x = old_x<br/>#旋轉系統<br/> def rotate(self):<br/> old_rotation = self.figure.rotation<br/> self.figure.rotate()<br/> if self.intersects():<br/> self.figure.rotation = old_rotation</p>
<p># Define some colors<br/># from https://stackoverflow.com/questions/3380726/converting-a-rgb-color-tuple-to-a-six-digit-code<br/>BLACK = '#%02x%02x%02x' % (0, 0, 0) #常量<br/>WHITE = '#%02x%02x%02x' % (255, 255, 255) #常量<br/>GRAY = '#%02x%02x%02x' % (128, 128, 128) #常量</p>
<p>done = False<br/>fps = 25 #幀數<br/>game = Tetris(20, 10)<br/>counter = 0 #等級</p>
<p>pressing_down = False<br/>#設定控制按鍵鍵盤R為旋轉方塊左右鍵為控制方塊移動D為直接將方塊往下到底</p>
<p>def key_down(eve):<br/> key = eve.keyCode<br/> #if event.type == pygame.QUIT:<br/> # 32 is pause<br/> if key == 32:<br/> done = True<br/> # 82 is R鍵 to rotate<br/> if key == 82:<br/> game.rotate()<br/> # 40 is down key<br/> if key == 40:<br/> pressing_down = True<br/> # 37 is left key<br/> if key == 37:<br/> game.go_side(-1)<br/> # 39 is right key<br/> if key == 39:<br/> game.go_side(1)<br/> # 68 is d key to move block to bottom<br/> if key == 68:<br/> game.go_space()<br/> # 27 is escape<br/> # reset the game<br/> if key == 27:<br/> game.__init__(20, 10)</p>
<p>def key_up(eve):<br/> key = eve.keyCode<br/> # 40 is down key<br/> if key == 40:<br/> pressing_down = False</p>
<p>#如果還沒結束<br/>def do_game():<br/> global counter<br/> if game.figure is None: #如果遊戲值為空新增一些方塊<br/> game.new_figure()<br/> counter += 1 <br/> if counter &gt; 100000:<br/> counter = 0<br/> if counter % (fps // game.level // 2) == 0 or pressing_down: #隨著等級越來越高難度也越來越大<br/> if game.state == "start":<br/> game.go_down()<br/> #把格子畫在窗口裡面一行一行的畫<br/> for i in range(game.height):<br/> for j in range(game.width):<br/> ctx.fillStyle = WHITE<br/> #ctx.scale(game.zoom, game.zoom)<br/> ctx.fillRect(game.x + game.zoom * j, game.y + game.zoom * i, game.zoom, game.zoom)<br/> if game.field[i][j] &gt; 0:<br/> ctx.fillStyle = '#%02x%02x%02x' % colors[game.field[i][j]]<br/> ctx.fillRect(game.x + game.zoom * j + 1, game.y + game.zoom * i + 1, game.zoom - 2, game.zoom - 1)<br/> ctx.lineWidth = 1<br/> ctx.strokeStyle = GRAY<br/> ctx.beginPath()<br/> ctx.rect(game.x + game.zoom * j, game.y + game.zoom * i, game.zoom, game.zoom)<br/> ctx.stroke()<br/> if game.figure is not None: #如果格子裡面不為0的時候把它畫出來<br/> for i in range(4):<br/> for j in range(4):<br/> p = i * 4 + j<br/> if p in game.figure.image():<br/> ctx.fillStyle = '#%02x%02x%02x' % colors[game.figure.color]<br/> ctx.fillRect(game.x + game.zoom * (j + game.figure.x) + 1,<br/> game.y + game.zoom * (i + game.figure.y) + 1,<br/> game.zoom - 2, game.zoom - 2)<br/>score_doc = html.DIV("score") #字體<br/>score_doc.id = "score" #顯示分數<br/>brython_div &lt;= score_doc</p>
<p>score = 0<br/>doc.addEventListener("keydown", key_down)<br/>doc.addEventListener("keyup", key_up)<br/>browser.timer.set_interval(do_game, fps)</p>
<h1>Tetris線上遊戲報告</h1>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js">
</script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 印出版次與關鍵字程式 --></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd(ev):
    bd = doc["brython_div"]
    bd.clear()
# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/41023120-1/1a2605a06ee874b4824caed67204fe0a/raw/9fd02ce86819897ed730076320e6ffeb58c590bf/Tetris%2520%25E7%25B7%259A%25E4%25B8%258A%25E9%2581%258A%25E6%2588%25B2%25E5%25B0%2588%25E6%25A1%2588%25E5%25A0%25B1%25E5%2591%258A"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace.editor.setValue(prog)
    Ace.editor.scrollToRow(0)
    Ace.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
doc['clear_bd'].bind('click', clear_bd)
# 呼叫函式執行
run()
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<!-- 存擋表單開始 --><form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src', 'kw_filename');" type="submit" value="Save"/></form><!-- 存擋表單結束 -->
<p></p>
<!-- 執行與清除按鈕開始 -->
<p><button id="kw_run">Run</button> <button id="kw_show_console">Output</button> <button id="kw_clear_console">清除輸出區</button><button id="clear_bd">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<!-- 執行與清除按鈕結束 -->
<p></p>
<!-- 程式執行 ouput 區 -->
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console"></textarea></div>
<!-- Brython 程式執行的結果, 都以 brython_div 作為切入位置 -->
<div id="brython_div"></div>
<div></div>
<h1>Tetris 加入計分系統</h1>
<div></div>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js">
</script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 印出版次與關鍵字程式 --></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd(ev):
    bd = doc["brython_div"]
    bd.clear()
# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/41023120-1/c84cbbef293b1689abef3bfb9c050190/raw/9d61cfdaead2fdfef0ca4c40fc9bbc35e7115700/Tetris%2520%25E7%25B7%259A%25E4%25B8%258A%25E9%2581%258A%25E6%2588%25B2%25E5%25B0%2588%25E6%25A1%2588%25E5%258A%25A0%25E8%25A8%2588%25E5%2588%2586%25E7%25B3%25BB%25E7%25B5%25B1%25E5%25A0%25B1%25E5%2591%258A"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace.editor.setValue(prog)
    Ace.editor.scrollToRow(0)
    Ace.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
doc['clear_bd'].bind('click', clear_bd)
# 呼叫函式執行
run()
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<!-- 存擋表單開始 --><form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src', 'kw_filename');" type="submit" value="Save"/></form><!-- 存擋表單結束 -->
<p></p>
<!-- 執行與清除按鈕開始 -->
<p><button id="kw_run">Run</button> <button id="kw_show_console">Output</button> <button id="kw_clear_console">清除輸出區</button><button id="clear_bd">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<!-- 執行與清除按鈕結束 -->
<p></p>
<!-- 程式執行 ouput 區 -->
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console"></textarea></div>
<!-- Brython 程式執行的結果, 都以 brython_div 作為切入位置 -->
<div id="brython_div"></div>
<div>
<h1>Final</h1>
<p>第1週<br/>創建倉儲<br/>說明如何利用 bat 執行設定 IPv6 網路連線</p>
<p>第2週<br/>解釋python程序是如何執行的</p>
<p>第3週<br/>解釋用 putty wink 視頻添加 ssh<br/>準備創建 Python 3.10.2 和 tcc 可攜帶的環境<br/>加入 1a 上課的兩個教學影片, 分別摘要前兩週的內容, 並說明如何自製可攜系統</p>
<p>第4週<br/>在 gist 加入能讀取網際檔案的範例程式<br/>加入 Brython 程式環境</p>
<p>第5週<br/>全校運動會</p>
<p>第6週<br/>清明節放假</p>
<p>第7週<br/>建立 Wink 教學影片<br/>建立 wcm2022<br/>配置 Brython 環境<br/>設定 Pelican 網誌<br/>Blogger 網誌同步<br/>計算機概論<br/>電腦硬體拆解<br/>建立 Virtualbox 虛擬主機<br/>安裝配置 nginx<br/>Windows 10 虛擬主機</p>
<p>第8週<br/>加入各學員倉儲與網頁連結<br/>添加數字線程頁面<br/>加入 w8 虛擬主機 Wink 專案檔<br/>整理課程主題, 並提出下半學期的課程教學要點</p>
<p>第9週<br/>為了方便性, 當期的課程網站, 仍採 Github Pages 伺服靜態網站. 使用的方法很簡單,<br/>只要建立 public Github 倉儲, 然後透過倉儲的 settings, 啟動倉儲的 Github Pages 功能,<br/>並指定從倉儲 main 分支中的 index.html 導引靜態網頁內容即可.</p>
<p>第10週<br/>加入電腦輔助設計室個人虛擬主機 IP 設定</p>
<p>第11週<br/>寫 Pelican 網誌</p>
<p>第12週<br/>學校 IPv6 網路不通</p>
<p>第13週<br/>說明如何在個人動態與靜態網頁中配置 Brython 程式環境, 並啟動執行線上程式)<br/>說明下列 Brython 程式各行功能</p>
<p>第14週<br/>將程式存入 Gist, 從舊資料中刪除沒有在註冊名單中的內容<br/>開始做俄羅斯方塊</p>
<p>第15週<br/>端午節放假<br/>俄羅斯方塊及加入計分系統</p>
<p>第16週<br/>期末報告整理</p>
<h1>期末任務1</h1>
</div>
</div>